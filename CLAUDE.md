# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a **NixOS Configuration** repository managed as a **Nix Flake**. It uses a modular structure powered by [flake-parts](https://flake.parts/) and [flake-file](https://github.com/vic/flake-file) (with `import-tree`), following the [dendritic pattern](https://github.com/mightyiam/dendritic).

### The Dendritic Pattern

The dendritic pattern treats every Nix file as a module of the top-level configuration. Key characteristics:

- **One file = one module**: Each `.nix` file is a complete flake-parts module implementing a single feature
- **Automatic discovery**: Files are auto-imported via import-tree; no manual import list maintenance required. Exception: files prefixed with `_` (e.g., `_keybindings.nix`) are **not** auto-imported — they are private helpers explicitly imported as functions by their parent module
- **Unified value sharing**: All files access the shared top-level config rather than passing values through `specialArgs`
- **File paths convey meaning**: Directory structure directly maps to flake outputs (e.g., `modules/hosts/katara.nix` → `nixosConfigurations.katara`)

### Flake-Parts

Flake-parts is a minimal framework that applies the NixOS module system to flakes. It enables splitting `flake.nix` into focused, reusable units while maintaining compatibility with standard flake attributes. The `flake.nix` in this repo is auto-generated by flake-file and delegates all logic to the `modules/` directory.

## Commands

```bash
# Apply configuration to current machine
sudo nixos-rebuild switch --flake .

# Build a specific host without applying
nix build .#nixosConfigurations.<hostname>.config.system.build.toplevel

# Test a host in QEMU VM (e.g., katara)
nix run .#katara-vm

# Validate all modules and configurations
nix flake check

# Format code
nix fmt

# Update flake inputs
nix flake update
```

## Architecture

### Module Hierarchy

The configuration flows: **Features → Bundles → Profiles → Hosts**

```
Bundles  →  Profiles  →  Hosts
   ↑     ↗     ↑      ↗    ↑
Features    Hardware     Users
```

- **`modules/features/`**: Individual software/service configurations, organized in subdirectories: `browser/` (firefox, librewolf), `editor/` (neovim, helix, claude-code), `wayland/` (waybar, foot, kanshi, theme), `shell/` (git, ssh), `system/` (boot, networking, fonts, locale, nix, sops), `network/` (vpn, wifi-home), `media/` (mpv), `virtualisation/` (podman), `desktop/` (thunar)
- **`modules/bundles/`**: Aggregate related modules into reusable sets. `base.nix` defines both `bundle-base` (container-safe foundation: fonts, home-manager, locale, nix) and `bundle-host` (extends base with auto-upgrade, boot, networking). `desktop/` is a directory with `default.nix` (bundle-desktop), `gnome.nix`, and `sway/`
- **`modules/profiles/`**: High-level roles combining bundles and features (laptop, developer, server)
- **`modules/hosts/`**: Per-machine configurations that select profiles and set hardware options
- **`modules/users/`**: User account definitions that bridge NixOS and Home Manager; imported by hosts or profiles
- **`modules/hardware/`**: Device and hardware configurations (audio, bluetooth, printing, dell-precision-5680)
- **`modules/core/`**: Core infrastructure (dendritic.nix, home-manager.nix, host-vm.nix, shell.nix, treefmt.nix)
- **`pkgs/`**: Custom package derivations not available in nixpkgs (e.g., cups-brother-hll3270cdw)

Features, bundles, and profiles can define both `nixosModules` and `homeModules` in the same file. User modules define both a `nixosModule` (account, groups) and a `homeModule` (packages, programs), wiring them together internally via `home-manager.users.<name>`.

### Layer Import Guidelines

The recommended import direction for each layer. When a change doesn't follow these guidelines, suggest a refactor that does (e.g., creating a profile to wrap features instead of importing them directly from a host).

| Layer | Recommended Imports | Avoid Importing |
|-------|-----------|---------------|
| **Features** | Other features (sparingly) | Bundles, profiles, hosts, users |
| **Bundles** | Features and other bundles | Profiles, hosts, users |
| **Profiles** | Bundles, features, and users | Other profiles, hosts |
| **Hosts** | Profiles, hardware, and users | Features, bundles directly |
| **Users** | Features and profiles (homeModules only) | Bundles, hosts |
| **Hardware** | External hardware modules (nixos-hardware) | Features, bundles, profiles, hosts, users |

### Naming Conventions

- **Hosts**: Avatar: The Last Airbender characters (katara, zuko, appa, momo)

### Secrets Management (sops-nix)

Secrets are managed with [sops-nix](https://github.com/Mic92/sops-nix) and encrypted using age keys derived from host SSH keys.

- **`.sops.yaml`**: Defines which age keys can decrypt which secret files. Creation rules match by filename pattern
- **`secrets/common.yaml`**: Secrets shared across all hosts
- **`secrets/<hostname>.yaml`**: Host-specific secrets (e.g., `secrets/zuko.yaml`)
- **Encryption**: Secrets are encrypted at rest in git; decrypted at activation time to `/run/secrets/` (NixOS) or user-level paths (Home Manager)
- **Referencing secrets in modules**: Use `sopsFile = "${self}/secrets/common.yaml";` (not relative paths) and `config.sops.secrets.<name>.path` for the decrypted file path
- **Limitation**: Sops secrets decrypt to files, so they can only be used with NixOS options that accept a **file path** (e.g., `passwordFile`, `secretFile`, `environmentFile`), not inline string values
- **Dev shell**: The `shellHook` in `shell.nix` auto-converts `~/.ssh/id_ed25519` to an age key via `SOPS_AGE_KEY` for editing secrets with `sops`

## Development Conventions

- **Git pull first**: Always run `git pull` before making any changes, as external processes may update the repository
- **MCP validation**: MUST use the `nixos` MCP server to verify that packages and options exist before adding them to configurations
- **Module structure**: Modules are functions taking `{ self, inputs, ... }` and define flake outputs directly via `flake.nixosModules.my-feature = ...;`. Modules can also define `perSystem` outputs for per-architecture tooling (formatters, dev shells, VM apps)
- **Module deduplication**: `nixosModules` and `homeModules` MUST be defined as **functions**, never bare attrsets. The NixOS/Home Manager module system can only deduplicate function modules (by reference identity). Bare attrsets (`= { ... }`) get a new anonymous key on each import, causing options like `home-manager.sharedModules` to be applied multiple times when imported through multiple paths (e.g., `bundle-host` imported by both `profile-laptop` and `bundle-desktop`). Use `= _: { ... }` if the module needs no arguments, or `= { pkgs, ... }: { ... }` if it does
- **Imports**: Use `self.nixosModules` to reference other modules: `imports = with self.nixosModules; [ bundle-host gnome ];`
- **Home module wiring**: nixosModules inject their corresponding homeModules via `home-manager.sharedModules = [ self.homeModules.my-feature ];` — this is the standard pattern for bridging NixOS and Home Manager config in a single feature file
- **Declaring inputs**: Core modules can declare flake inputs inline via `flake-file.inputs.<name>.url = "github:owner/repo";` — prefer this over editing `flake.nix` directly
- **flake.nix**: Never modify manually; it is regenerated by running `nix run .#write-flake`. New inputs should be declared inline in modules using `flake-file.inputs`
- **Pre-commit workflow** (MUST follow this order before every commit):
  1. Run `nix fmt` to ensure consistent code style
  1. Stage files with `git add` (the flake only sees tracked files)
- **Pre-merge validation**: Run `nix flake check` before merging or pushing — do NOT merge if checks fail. This is not required after every single change, only before finalizing
- **Committing**: Always present changes and proposed commit message to the user for explicit approval before committing
